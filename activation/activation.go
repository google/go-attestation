// Package activation verifies AIK parameters & the binding between AIKs & EKs.
package activation

import (
	"bytes"
	"crypto"
	"crypto/rsa"
	"errors"
	"fmt"
	"io"

	"github.com/google/go-attestation/attest"
	tpm1 "github.com/google/go-tpm/tpm"
	"github.com/google/go-tpm/tpm2"
)

const (
	minRSABits          = 2048
	tpm20GeneratedMagic = 0xff544347
)

func cryptoHash(h tpm2.Algorithm) (crypto.Hash, error) {
	switch h {
	case tpm2.AlgSHA1:
		return crypto.SHA1, nil
	case tpm2.AlgSHA256:
		return crypto.SHA256, nil
	case tpm2.AlgSHA384:
		return crypto.SHA384, nil
	case tpm2.AlgSHA512:
		return crypto.SHA512, nil
	default:
		return crypto.Hash(0), fmt.Errorf("unsupported signature digest: %v", h)
	}
}

// Parameters encapsulates the inputs for activating an AIK.
type Parameters struct {
	// TPMVersion holds the version of the TPM, either 1.2 or 2.0.
	TPMVersion attest.TPMVersion

	// EK, the endorsement key, describes an asymmetric key who's
	// private key is permenantly bound to the TPM.
	//
	// Activation will verify that the provided EK is held on the same
	// TPM as the AIK. However, it is the callers responsibility to
	// ensure the EK they provide corresponds to the the device which
	// they are trying to associate the AIK with.
	EK crypto.PublicKey

	// AIK, the Attestation Identity Key, describes the properties of
	// an asymmetric key (managed by the TPM) which signs attestation
	// structures.
	// The values from this structure can be obtained by calling
	// Parameters() on an attest.AIK.
	AIK attest.AIKParameters

	// Rand is a source of randomness to generate a seed and secret for the
	// challenge.
	//
	// If nil, this defaults to crypto.Rand.
	Rand io.Reader

	// InsecureSkipROCACheck disables the check for ROCA vulnerable private keys.
	// If false & the key is vulnerable, calls to Generate() will return an error.
	InsecureSkipROCACheck bool

	// InsecureSkipParametersCheck disables the check for non-exportable key
	// usage & acceptable key sizes. If false & the key has any of these issues,
	// calls to Generate() will return an error.
	InsecureSkipParametersCheck bool
}

// ROCAVulnerable returns true if the key is vulnerable to ROCA.
func (p *Parameters) ROCAVulnerable() bool {
	return true
}

// checkAIKParameters examines properties of an AIK and a creation
// attestation, to determine if it is suitable for use as an attestation key.
func (p *Parameters) checkAIKParameters() error {
	switch p.TPMVersion {
	case attest.TPMVersion12:
		return p.checkTPM12AIKParameters()

	case attest.TPMVersion20:
		return p.checkTPM20AIKParameters()

	default:
		return fmt.Errorf("TPM version %d not supported", p.TPMVersion)
	}
	panic("unreachable")
}

func (p *Parameters) checkTPM12AIKParameters() error {
	pub, err := tpm1.UnmarshalPubRSAPublicKey(p.AIK.Public)
	if err != nil {
		return fmt.Errorf("unmarshalling public key: %v", err)
	}
	if bits := pub.Size() * 8; bits < minRSABits {
		return fmt.Errorf("attestation key too small: must be at least %d bits but was %d bits", minRSABits, bits)
	}
	return nil
}

func (p *Parameters) checkTPM20AIKParameters() error {
	if len(p.AIK.CreateSignature) < 8 {
		return fmt.Errorf("signature is too short to be valid: only %d bytes", len(p.AIK.CreateSignature))
	}

	pub, err := tpm2.DecodePublic(p.AIK.Public)
	if err != nil {
		return err
	}
	_, err = tpm2.DecodeCreationData(p.AIK.CreateData)
	if err != nil {
		return err
	}
	att, err := tpm2.DecodeAttestationData(p.AIK.CreateAttestation)
	if err != nil {
		return err
	}
	if att.Type != tpm2.TagAttestCreation {
		return fmt.Errorf("attestation does not apply to creation data, got tag %x", att.Type)
	}

	switch pub.Type {
	case tpm2.AlgRSA:
		if pub.RSAParameters.KeyBits < minRSABits {
			return fmt.Errorf("attestation key too small: must be at least %d bits but was %d bits", minRSABits, pub.RSAParameters.KeyBits)
		}
	default:
		return fmt.Errorf("public key of alg 0x%x not supported", pub.Type)
	}

	// Compute & verify that the creation data matches the digest in the
	// attestation structure.
	nameHashConstructor, err := pub.NameAlg.HashConstructor()
	if err != nil {
		return err
	}
	h := nameHashConstructor()
	h.Write(p.AIK.CreateData)
	if !bytes.Equal(att.AttestedCreationInfo.OpaqueDigest, h.Sum(nil)) {
		return errors.New("attestation refers to different public key")
	}

	// Make sure the AIK has sane key parameters (Attestation can be faked if an AIK
	// can be used for arbitrary signatures).
	// We verify the following:
	// - Key is TPM backed.
	// - Key is TPM generated.
	// - Key is a restricted key (means it cannot do arbitrary signing/decrypt ops).
	// - Key cannot be duplicated.
	// - Key was generated by a call to TPM_Create*.
	if att.Magic != tpm20GeneratedMagic {
		return errors.New("creation attestation was not produced by a TPM")
	}
	if (pub.Attributes & tpm2.FlagFixedTPM) == 0 {
		return errors.New("AIK is exportable")
	}
	if ((pub.Attributes & tpm2.FlagRestricted) == 0) || ((pub.Attributes & tpm2.FlagFixedParent) == 0) || ((pub.Attributes & tpm2.FlagSensitiveDataOrigin) == 0) {
		return errors.New("provided key is not limited to attestation")
	}

	// Verify the attested creation name matches what is computed from
	// the public key.
	match, err := att.AttestedCreationInfo.Name.MatchesPublic(pub)
	if err != nil {
		return err
	}
	if !match {
		return errors.New("creation attestation refers to a different key")
	}

	// Check the signature over the attestation data verifies correctly.
	pk := rsa.PublicKey{E: int(pub.RSAParameters.Exponent), N: pub.RSAParameters.Modulus}
	signHashConstructor, err := pub.RSAParameters.Sign.Hash.HashConstructor()
	if err != nil {
		return err
	}
	hsh := signHashConstructor()
	hsh.Write(p.AIK.CreateAttestation)
	verifyHash, err := cryptoHash(pub.RSAParameters.Sign.Hash)
	if err != nil {
		return err
	}
	//TODO(jsonp): Decode to tpm2.Signature & use that, once PR to expose DecodeSignature() is in.
	if err := rsa.VerifyPKCS1v15(&pk, verifyHash, hsh.Sum(nil), p.AIK.CreateSignature[6:]); err != nil {
		return fmt.Errorf("could not verify attestation: %v", err)
	}

	return nil
}

// Generate returns a credential activation challenge, which can be provided
// to the TPM to verify the AIK parameters given are authentic & the AIK
// is present on the same TPM as the EK.
func (p *Parameters) Generate() (secret []byte, ec *attest.EncryptedCredential, err error) {
	if !p.InsecureSkipParametersCheck {
		if err := p.checkAIKParameters(); err != nil {
			return nil, nil, err
		}
	}

	return nil, nil, nil
}
